{"debug_symbols":[{"locations":{"32":[{"span":{"start":208,"end":253},"file":0},{"span":{"start":755,"end":793},"file":23}],"33":[{"span":{"start":267,"end":285},"file":0}],"34":[{"span":{"start":299,"end":318},"file":0}]}}],"file_map":{"0":{"source":"use dep::std;\n\nfn main(\n    reqDomain: Field,\n    passcode: Field,\n    serverHash: pub Field,\n    domain: pub Field,\n    chainId: pub Field,\n    txHash: pub [u8; 32],\n    amount: pub Field\n) {\n    let hash = std::hash::pedersen_hash([passcode, chainId]);\n\n    assert(hash == serverHash);\n    assert(domain == reqDomain);\n}\n\n#[test]\nfn test_main() {\n    let reqDomain = 0x45318970bfff215a328f56895f3a97d4f276a44c24c135c12c37867a1f667b8a;\n    let passcode = 0x33353435;\n    let serverHash = 0x2a839d1e09d517235076fffad1d4f80fdf1a05fac8623e918b8a565e75fed6ad;\n    let domain = 0x45318970bfff215a328f56895f3a97d4f276a44c24c135c12c37867a1f667b8a;\n    let chainId = 0x0000000000000000000000000000000000000000000000000000000000000763;\n    let txHash = [\n        161, 222, 152, 134, 0, 164, 44, 75, 74, 176, 137, 182, 25, 41, 124, 23, 213, 60, 255, 174, 93, 81, 32, 216, 45, 138, 146, 208, 187, 59, 120, 242\n    ];\n    let amount = 0x38D7EA4C68000;\n    main(reqDomain, passcode, serverHash, domain, chainId, txHash, amount);\n}\n","path":"/Users/anoy/Documents/Hackathon Projects/circuits/burn_prove/src/main.nr"},"23":{"source":"mod poseidon;\nmod mimc;\n\n#[foreign(sha256)]\npub fn sha256<N>(_input: [u8; N]) -> [u8; 32] {}\n\n#[foreign(blake2s)]\npub fn blake2s<N>(_input: [u8; N]) -> [u8; 32] {}\n\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint {\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(_input: [Field; N], _separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\npub fn pedersen_hash<N>(input: [Field; N]) -> Field {\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(_input: [Field; N], _separator: u32) -> Field {}\n\npub fn hash_to_field<N>(_input: [Field; N]) -> Field {\n    let mut inputs_as_bytes = [];\n\n    for i in 0..N {\n        let input_bytes = _input[i].to_le_bytes(32);\n        for i in 0..32 {\n            inputs_as_bytes = inputs_as_bytes.push_back(input_bytes[i]);\n        }\n    }\n\n    let hashed_input = blake2s(inputs_as_bytes);\n    crate::field::bytes32_to_field(hashed_input)\n}\n\n#[foreign(keccak256)]\npub fn keccak256<N>(_input: [u8; N], _message_size: u32) -> [u8; 32] {}\n\n","path":"std/hash.nr"}},"warnings":[]}